# frozen_string_literal: true

json ||= {}
key_new = attribute_key(key, definition)
json[key_new] ||= []

api_property_definition = api_definition(definition)

new_options = options.dup
new_options[:fields] = subtree_for(key_new, options[:fields]).map { |fields| fields[1..-1] }
new_options[:include] = subtree_for(key_new, options[:include]).map { |includes| includes[1..-1] }
new_options[:languages] = options[:languages]
new_options[:full] = included_attribute?(key_new, options[:include]) || included_attribute?(key_new, options[:fields])

classification_aliases = load_value_object(content, key, value, options[:languages], api_property_definition)&.primary_classification_aliases

classification_json = render 'classifications', classification_aliases: classification_aliases, key: key_new, definition: {}, options: new_options

json['@id'] = SecureRandom.uuid
json['@type'] = api_property_definition['types']
json['dc:multilingual'] = (content.embedded? ? options.dig(:translatable_embedded) || false : content.translatable?) if options[:field_filter] == false || (included_attribute?('dc:multilingual', options[:include]) || included_attribute?('dc:multilingual', options[:fields]))
json['dc:translation'] = content.available_locales if options[:field_filter] == false || (included_attribute?('dc:translation', options[:include]) || included_attribute?('dc:translation', options[:fields]))
json['dc:classification'] = classification_json[key_new]

{
  api_property_definition['name'] => json.reject { |_k, v| v.blank? }
}
